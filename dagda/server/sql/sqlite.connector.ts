import { OperationType, SQLTransactionData } from "@dagda/shared/sql/transaction";
import { ForeignKeys, SQLConnector, SQLTransactionResult, TablesDefinition } from "@dagda/shared/sql/types";
import sqlite from "better-sqlite3";

type SQLValue = number | string | null;

export class SQLiteConnector<Tables extends TablesDefinition> extends SQLConnector<Tables> {

    protected _db: sqlite.Database;

    constructor(filename: string, foreignKeys: ForeignKeys<Tables>) {
        super(foreignKeys);
        this._db = new sqlite(filename);
    }

    public get db(): sqlite.Database { return this._db; }

    //#region General management ----------------------------------------------

    public override async submit(transactionData: SQLTransactionData<Tables>): Promise<SQLTransactionResult> {
        const result: SQLTransactionResult = {
            updatedIds: {}
        }
        try {
            await this.run("BEGIN");
            for (const operation of transactionData) {
                switch (operation.type) {
                    case OperationType.INSERT: {
                        this._updateForeignKeys(result, operation.options.table, operation.options.item);
                        const columnNames = [];
                        const values: SQLValue[] = [];
                        for (const key in operation.options.item) {
                            if (key === "id") {
                                // Autogenerated
                                continue;
                            }
                            columnNames.push(key);
                            values.push(JSON.stringify(operation.options.item[key]));
                        }
                        const query = `INSERT INTO ${operation.options.table as string} (${columnNames.join(",")}) VALUES (${columnNames.map(_ => "?").join(",")})`;
                        const newId = await this.insert(query, values);
                        result.updatedIds[operation.options.item.id] = newId;
                        break;
                    }
                    case OperationType.UPDATE: {
                        this._updateForeignKeys(result, operation.options.table, operation.options.values as any);
                        const columnNames = [];
                        const values: SQLValue[] = [];
                        for (const key in operation.options.values) {
                            if (key === "id") {
                                // Autogenerated, you cannot update it
                                continue;
                            }
                            columnNames.push(`"${key}"=?`);
                            values.push(JSON.stringify(operation.options.values[key]));
                        }
                        values.push(this._getUpdatedId(result, operation.options.id));
                        const query = `UPDATE ${operation.options.table as string} SET ${columnNames.join(",")} WHERE id=?`;
                        await this.run(query, values);
                        break;
                    }
                    case OperationType.DELETE: {
                        const query = `DELETE FROM ${operation.options.table as string} WHERE id=?`;
                        await this.run(query, [this._getUpdatedId(result, operation.options.id)]);
                        break;
                    }
                    default:
                        throw new Error("Not implemented");
                }
            }
            await this.run("COMMIT");
        } catch (e) {
            this.run("ROLLBACK");
            throw e; // Forward the exception to notice the caller that there was an error
        }

        return result;
    }

    //#region Tools -----------------------------------------------------------

    public async initTable<TN extends keyof Tables, T extends Tables[TN] = Tables[TN]>(
        tableName: TN,
        fieldTypes: { [fields in keyof Required<Omit<T, "id">>]: string }): Promise<void> {
        const fieldTypesFull: { [fields in keyof Required<T>]: string } = {
            "id": "INTEGER PRIMARY KEY AUTOINCREMENT",
            ...fieldTypes
        } as { [fields in keyof Required<T>]: string };
        try {
            this.run("BEGIN");
            await this._createTableIfNeeded(tableName, fieldTypesFull);
            for (const fieldName in fieldTypesFull) {
                this._createFieldIfNeeded(tableName, fieldName as keyof Required<T>, fieldTypesFull[fieldName]);
            }
            this.run("COMMIT");
        } catch (e) {
            console.error(e);
            this.run("ROLLBACK");
            throw e;
        }
    }

    protected _createTableIfNeeded<TN extends keyof Tables, T extends Tables[TN] = Tables[TN]>(tableName: TN, fieldTypes: { [fields in keyof Required<T>]: string }): Promise<void> {
        return this.run(`CREATE TABLE IF NOT EXISTS ${tableName as string} (${Object.entries(fieldTypes).map(([fieldName, fieldType]) => `'${fieldName}' ${fieldType}`).join(", ")})`, undefined);
    }

    /** @returns true if column was created */
    protected _createFieldIfNeeded<TN extends keyof Tables, T extends Tables[TN] = Tables[TN]>(tableName: TN, fieldName: keyof Required<T>, fieldType: string): Promise<boolean> {
        return this.run(`ALTER TABLE ${tableName as string} ADD COLUMN ${fieldName as string} ${fieldType}`, undefined).catch(() => false).then(() => true);
    }

    /** Get rows */
    public all<Row>(query: string, params: SQLValue[] = []): Promise<Row[]> {
        try {
            const rows = this._db.prepare(query).all(...params) as Row[];
            return Promise.resolve(rows);
        } catch (e) {
            console.log(query, params);
            return Promise.reject(e);
        }
    }

    public get<Row>(query: string, params: SQLValue[] = []): Promise<Row | null> {
        try {
            const row = this._db.prepare(query).get(...params) as Row | undefined;
            return Promise.resolve(row ?? null);
        } catch (e) {
            console.log(query, params);
            return Promise.reject(e);
        }
    }

    public async insert(query: string, params: SQLValue[] = []): Promise<number> {
        try {
            await this.run(query, params);
            return (await this.get<{ id: number }>("SELECT last_insert_rowid() AS id", []))?.id ?? -1;
        } catch (e) {
            return Promise.reject(e);
        }
    }

    public run(query: string, params: SQLValue[] = []): Promise<void> {
        console.log(query, params);
        try {
            this._db.prepare(query).run(...params);
            return Promise.resolve();
        } catch (e) {
            return Promise.reject(e);
        }
    }

    //#endregion

}