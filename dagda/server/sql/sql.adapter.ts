import { _getUpdatedId, _updateForeignKeys } from "@dagda/shared/entities/handler";
import { EntitiesModel } from "@dagda/shared/entities/model";
import { TablesDefinition } from "@dagda/shared/entities/types";
import { OperationType, SQLTransactionData, SQLTransactionResult } from "@dagda/shared/sql/transaction";
import * as format from "pg-format";
import { AbstractSQLRunner, SQLConnection, SQLValue, sqlValue } from "./runner";

/** Transaction submit implementation for SQLite */
export function generateSubmit<Tables extends TablesDefinition, Contexts>(runner: AbstractSQLRunner<SQLConnection>, model: EntitiesModel<any, any>) {
    return function submit<Tables extends TablesDefinition, Contexts>(transactionData: SQLTransactionData<Tables, Contexts>): Promise<SQLTransactionResult> {
        return runner.withTransaction(async (connection: SQLConnection) => {
            const result: SQLTransactionResult = {
                updatedIds: {}
            }
            const foreignKeys = model.getForeignKeys() as any;
            for (const operation of transactionData.operations) {
                switch (operation.type) {
                    case OperationType.INSERT: {
                        _updateForeignKeys(foreignKeys, result, operation.options.table, operation.options.item);
                        const columnNames = [];
                        const values: SQLValue[] = [];
                        for (const key in operation.options.item) {
                            if (key === "id") {
                                // Autogenerated
                                continue;
                            }
                            columnNames.push(key);
                            values.push(sqlValue(operation.options.item[key]));
                        }
                        let paramIndex = 1;
                        const query = format.default(`INSERT INTO %I (%I) VALUES (%L)`, operation.options.table as string, columnNames, values);
                        const newId = await connection.insert(query);
                        if (newId != null) {
                            result.updatedIds[operation.options.item.id] = newId;
                        }
                        break;
                    }
                    case OperationType.UPDATE: {
                        _updateForeignKeys(foreignKeys, result, operation.options.table as string, operation.options.values as any);
                        const columnNameEqualValues = [];
                        const params: SQLValue[] = [];
                        for (const key in operation.options.values) {
                            if (key === "id") {
                                // Autogenerated, you cannot update it
                                continue;
                            }
                            columnNameEqualValues.push(`%I=%L`);
                            params.push(key);
                            params.push(sqlValue(operation.options.values[key]));
                        }
                        params.push(_getUpdatedId(result, operation.options.id));
                        const query = format.default(`UPDATE %I SET ${columnNameEqualValues.join(",")} WHERE "id"=%L`, operation.options.table as string, ...params);
                        await connection.run(query);
                        break;
                    }
                    case OperationType.DELETE: {
                        const query = format.default(`DELETE FROM %I WHERE "id"=%L`, operation.options.table as string, _getUpdatedId(result, operation.options.id));
                        await connection.run(query);
                        break;
                    }
                    default:
                        throw new Error("Not implemented");
                }
            }
            return result;
        });
    }
}