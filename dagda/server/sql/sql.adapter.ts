import { asNamed } from "@dagda/shared/entities/named.types";
import { BaseEntity, ForeignKeys, TablesDefinition } from "@dagda/shared/entities/types";
import { OperationType, SQLTransactionData, SQLTransactionResult } from "@dagda/shared/sql/transaction";
import { AbstractSQLRunner, SQLConnection, SQLValue, sqlValue } from "./runner";

/** Transaction submit implementation for SQLite */
export function submit<Tables extends TablesDefinition, Contexts>(runner: AbstractSQLRunner<any, any, SQLConnection>, transactionData: SQLTransactionData<Tables, Contexts>): Promise<SQLTransactionResult> {
    return runner.withTransaction(async (connection: SQLConnection) => {
        const result: SQLTransactionResult = {
            updatedIds: {}
        }
        for (const operation of transactionData.operations) {
            switch (operation.type) {
                case OperationType.INSERT: {
                    // _updateForeignKeys(runner.foreignKeys, result, operation.options.table, operation.options.item);
                    const columnNames = [];
                    const values: SQLValue[] = [];
                    for (const key in operation.options.item) {
                        if (key === "id") {
                            // Autogenerated
                            continue;
                        }
                        columnNames.push(key);
                        values.push(sqlValue(operation.options.item[key]));
                    }
                    let paramIndex = 1;
                    const query = `INSERT INTO ${operation.options.table as string} (${columnNames.map(n => `"${n}"`).join(",")}) VALUES (${columnNames.map(_ => `$${paramIndex++}`).join(",")})`;
                    const newId = await connection.insert(query, ...values);
                    if (newId != null) {
                        result.updatedIds[operation.options.item.id] = newId;
                    }
                    break;
                }
                case OperationType.UPDATE: {
                    // _updateForeignKeys(runner.foreignKeys, result, operation.options.table, operation.options.values as any);
                    const columnNameEqualValues = [];
                    const values: SQLValue[] = [];
                    let paramIndex = 1;
                    for (const key in operation.options.values) {
                        if (key === "id") {
                            // Autogenerated, you cannot update it
                            continue;
                        }
                        columnNameEqualValues.push(`"${key}"=$${paramIndex++}`);
                        values.push(sqlValue(operation.options.values[key]));
                    }
                    values.push(_getUpdatedId(result, operation.options.id));
                    const query = `UPDATE "${operation.options.table as string}" SET ${columnNameEqualValues.join(",")} WHERE "id"=$${paramIndex++}`;
                    await connection.run(query, ...values);
                    break;
                }
                case OperationType.DELETE: {
                    const query = `DELETE FROM ${operation.options.table as string} WHERE "id"=$1`;
                    await connection.run(query, _getUpdatedId(result, operation.options.id));
                    break;
                }
                default:
                    throw new Error("Not implemented");
            }
        }
        return result;
    });
}

//#region Foreign keys tools --------------------------------------------------

/** 
 * Update item's foreign keys to new uids.
 * @throws If id cannot be updated.
 */
function _updateForeignKeys<Tables extends TablesDefinition, TableName extends keyof Tables>(foreignKeys: ForeignKeys<Tables>, result: SQLTransactionResult, table: TableName, item: Tables[TableName]): void {
    const tableForeignKeys = foreignKeys[table];
    for (const key in tableForeignKeys) {
        if (tableForeignKeys[key]) {
            const temporaryId = item[key as keyof Tables[TableName]] as BaseEntity["id"];
            if (temporaryId == null) {
                continue;
            }
            const newId = _getUpdatedId(result, temporaryId);
            item[key as keyof Tables[TableName]] = newId as Tables[TableName][keyof Tables[TableName]];
        }
    }
}

/** 
 * Get id updated after insert. If id is positive, it is returned as-is.
 * @throws If id is negative and cannot be updated
 */
function _getUpdatedId(result: SQLTransactionResult, id: BaseEntity["id"]): BaseEntity["id"] {
    if (id >= 0) {
        return id;
    } else {
        const newId = result.updatedIds[id] ?? id;
        if (newId == null) {
            throw new Error(`Failed to update ${id}`);
        }
        return asNamed(result.updatedIds[id] ?? id);
    }
}

//#endregion
