import { OperationType, SQLTransaction } from "@dagda/sql-shared/src/sql.transaction";
import { SQLConnector, BaseDTO, TablesDefinition, TransactionResult, ForeignKeys } from "@dagda/sql-shared/src/sql.types";
import sqlite from "better-sqlite3";

type SQLValue = number | string | null;

export class SQLiteConnector<Tables extends TablesDefinition> extends SQLConnector<Tables> {
    /** The database */
    protected _db: sqlite.Database;

    constructor(foreignKeys: ForeignKeys<Tables>, filename: string) {
        super(foreignKeys);
        this._db = new sqlite(filename);
    }

    //#region General management ----------------------------------------------

    public override getItems<TableName extends keyof Tables>(tableName: TableName): Promise<Tables[TableName][]> {
        return this._all<Tables[TableName]>(`SELECT * FROM ${tableName as string}`);
    }

    public override async submit(transaction: SQLTransaction<Tables>): Promise<TransactionResult> {
        const result: TransactionResult = {
            updatedIds: {}
        }

        for (const operation of transaction.operations) {
            switch (operation.type) {
                case OperationType.INSERT: {
                    this._updateForeignKeys(result, operation.options.table, operation.options.item);
                    const columnNames = [];
                    const values: SQLValue[] = [];
                    for (const key in operation.options.item) {
                        if (key === "id") {
                            // Autogenerated
                            continue;
                        }
                        columnNames.push(key);
                        values.push(JSON.stringify(operation.options.item[key]));
                    }
                    const query = `INSERT INTO ${operation.options.table as string} (${columnNames.join(",")}) VALUES (${columnNames.map(_ => "?").join(",")})`;
                    const newId = await this._insert(query, values);
                    result.updatedIds[operation.options.item.id] = newId;
                    break;
                }
                case OperationType.UPDATE: {
                    this._updateForeignKeys(result, operation.options.table, operation.options.values as any);
                    const columnNames = [];
                    const values: SQLValue[] = [];
                    for (const key in operation.options.values) {
                        if (key === "id") {
                            // Autogenerated
                            continue;
                        }
                        columnNames.push(`"${key}"=?`);
                        values.push(JSON.stringify(operation.options.values[key]));
                    }
                    values.push(operation.options.id);
                    const query = `UPDATE ${operation.options.table as string} SET ${columnNames.join(",")} WHERE id=?`;
                    await this._run(query, values);
                    break;
                }
                case OperationType.DELETE: {
                    const query = `DELETE FROM ${operation.options.table as string} WHERE id=?`;
                    await this._run(query, [operation.options.id]);
                    break;
                }
                default:
                    throw new Error("Not implemented");
            }
        }


        return result;
    }

    //#region Tools -----------------------------------------------------------

    public async initTable<TN extends keyof Tables, T extends Tables[TN] = Tables[TN]>(
        tableName: TN,
        fieldTypes: { [fields in keyof Required<Omit<T, "id">>]: string }): Promise<void> {
        const fieldTypesFull: { [fields in keyof Required<T>]: string } = {
            ...fieldTypes,
            "id": "INTEGER PRIMARY KEY AUTOINCREMENT"
        } as { [fields in keyof Required<T>]: string };
        await this._createTableIfNeeded(tableName, fieldTypesFull);
        for (const fieldName in fieldTypesFull) {
            this._createFieldIfNeeded(tableName, fieldName as keyof Required<T>, fieldTypesFull[fieldName]);
        }
    }

    protected _createTableIfNeeded<TN extends keyof Tables, T extends Tables[TN] = Tables[TN]>(tableName: TN, fieldTypes: { [fields in keyof Required<T>]: string }): Promise<void> {
        return this._run(`CREATE TABLE IF NOT EXISTS ${tableName as string} (${Object.entries(fieldTypes).map(([fieldName, fieldType]) => `'${fieldName}' ${fieldType}`).join(", ")})`, undefined);
    }

    /** @returns true if column was created */
    protected _createFieldIfNeeded<TN extends keyof Tables, T extends Tables[TN] = Tables[TN]>(tableName: TN, fieldName: keyof Required<T>, fieldType: string): Promise<boolean> {
        return this._run(`ALTER TABLE ${tableName as string} ADD COLUMN ${fieldName as string} ${fieldType}`, undefined).catch(() => false).then(() => true);
    }

    /** Get rows */
    protected _all<Row>(query: string, params: SQLValue[] = []): Promise<Row[]> {
        try {
            const rows = this._db.prepare(query).all(...params) as Row[];
            return Promise.resolve(rows);
        } catch (e) {
            console.log(query, params);
            return Promise.reject(e);
        }
    }

    protected _get<Row>(query: string, params: SQLValue[] = []): Promise<Row | null> {
        try {
            const row = this._db.prepare(query).get(...params) as Row | undefined;
            return Promise.resolve(row ?? null);
        } catch (e) {
            console.log(query, params);
            return Promise.reject(e);
        }
    }

    protected async _insert(query: string, params: SQLValue[] = []): Promise<number> {
        try {
            await this._run(query, params);
            return (await this._get<{ id: number }>("SELECT last_insert_rowid() AS id", []))?.id ?? -1;
        } catch (e) {
            return Promise.reject(e);
        }
    }

    protected _run(query: string, params: SQLValue[] = []): Promise<void> {
        console.log(query, params);
        try {
            this._db.prepare(query).run(...params);
            return Promise.resolve();
        } catch (e) {
            return Promise.reject(e);
        }
    }

    //#endregion

}